# 上

#### 1、构造函数最好用 初始化列表

#### 2、传递 和 返回 参数最好用 引用

（1）局部变量 （即在函数内创建的临时对象） 不可以返回 引用
（2）传递者无需知道接收者是以 引用 形式接收
（3）引用 返回，为了可以实现链式操作
（4）*this返回

#### 3、写函数的时候考虑要不要加 const

#### 4、符号重载

（1）成员函数来 重载的函数，传递的参数隐藏了 this
（2）非成员函数的重载，无this隐藏在里头
（3）特殊的操作符重载，比如“<<”，只能用非成员函数重载

#### 5、拷贝构造、拷贝赋值、析构函数----->三大函数 

（1）考虑成员变量有没有指针
（2）带有指针成员的类，一定要独立的拷贝构造和拷贝赋值函数，来避免浅拷贝
（3）拷贝赋值：先把自己消灭掉，再分配一个新的空间，最后装入要拷贝的值；
                             做检测自我赋值，可以避免上面做的事情，同时可以避免拷贝赋值出错

#### 6、堆heap、栈stack 与 内存空间

（1）栈：是存在于某作用域的一块内存空间。比如，当调用函数，函数本身即会形成一个 栈 用来放置它接收的参数，以及返回地址。在函数本体内声明的任何变量，其所使用的内存块都取自上述stack
（2）堆：或称system heap，是指由操作系统提供的一块全局（global）内存空间，程序可动态分配从某中获得若干区块
（3）new出来的对象，最后都要手动delete掉它，否则，它的指针死亡了，但它所指的那块内存还在，则会导致内存泄漏
（4）new对象指针执行的内部操作：先分配内存，内部调用malloc；然后转型；最后执行构造函数
（5）delete对象指针的内部操作：先调用析构函数；再释放内存，内部调用free

#### 7、类模板、函数模板

（1）编译器会对函数模板进行引数推倒
（2）标准库中的算法都是用类模板

#### 8、复合 Composite

（1）类中的成员变量有其他的类对象
（2）构造，由内到外：container的构造函数首先调用component的默认构造函数，然后才执行自己
（3）析构，由外到内：container的析构函数先执行自己，然后才调用component的析构函数

#### 9、委托 Delegation

（1）类中的成员变量有其他类指针，即通过引用方式的复合

#### 10、继承 Inheritance

（1）父类的构造函数必须是虚函数，否则会出现undefined behavior
（2）构造由内而外，析构由外而内

#### 11、虚函数 与 多态

（1）涉及到设计模式的内容，不太懂



#### 12、 inline

在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 **inline** 修饰符，表示为内联函数。

栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。

在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。

函数若在 class body 内定义完成，便自动成为 inline 候选人



# 下

1、pointer-like classes

2、function-like classes 仿函数
（1）里面重载了()

3、关于vptr与vtbl
（1）虚函数在继承下，有两种调用机制

```c++
(*(p->vptr)[n])(p);
(*p->vptr[n])(p);
```

（2）函数被调用的时候，编译器会先判定是静态绑定（call）还是动态绑定
（3）动态绑定的情况：指针调用；up pass向上转型方式创建对象；调用虚函数
（4）动态绑定走的是虚机制，即第一个代码